1. **1. 两数之和**
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

方法：
1. 暴力求解，超内存；
2. hash方法，一边遍历，一边建立hash表，这样后面再次判断的时候，先查表，在决定是否继续遍历。
代码：
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
```

2. **402. 移掉K位数字**
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

方法：
遍历k次，每次从左找到第一个比后一位大的数，删掉 代码：
```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        if(num.length()==k)
            return "0";
        int count=0;
        //给字符串加一个末尾0，便于遍历。
        num+="0";
        while (count<k)
        {
            for(int i=0;i<num.length();i++){
                if(int(num[i])>int(num[i+1])){
                    count++;
                    num.erase(i,1);
                    break;
                }
            }
        }
        //记得删除末尾加的0
        num.pop_back();
        //去掉首个‘0’
        while(num.length()>1 && num[0]=='0')
            num.erase(0,1);
        return num;
    }
```

3. **406. 根据身高重建队列**
假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

示例

输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]

方法：非常妙~~~~~
先排个序，按照身高从高到低、k值从低到高排序一下，这样再逐个遍历元素，插入结果中，这时候不用考虑身高问题，直接根据k值和结果长度进行比较，就可以直接知道应该插入在哪个位置了。
参考：https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/
代码：
```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        res = []
        people = sorted(people, key = lambda x: (-x[0], x[1]))
        for p in people:
            if len(res) <= p[1]:
                res.append(p)
            elif len(res) > p[1]:
                res.insert(p[1], p)
        return res
```
4. **2. 两数相加**
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)

输出：7 -> 0 -> 8

原因：342 + 465 = 807

方法：
模拟相加，维护进位，注意链表可以不等长

代码：
```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode head;
        ListNode *p=&head;
        int bit=0;
        while(l1 || l2){
            int s=bit;
            if(l1)
                s+=l1->val;
            if(l2)
                s+=l2->val;
            if(s>9){
                s-=10;
                bit=1;
            }
            else{
                bit=0;
            }
            ListNode *t=new ListNode(s);
            p->next=t;
            p=p->next;
            if(l1)
                l1=l1->next;
            if(l2)
                l2=l2->next;
        }
        if(bit){
            ListNode *t=new ListNode(bit);
            p->next=t;
        }
        p=&head;
        return p->next;
    }
};
```

5. **1030. 距离顺序排列矩阵单元格**
给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 <= r < R 且 0 <= c < C。

另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。

返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）

方法：
1. 直接都求出距离，然后排序

```c++
class Solution {
public:
    vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0) {
        vector<vector<int>> ret;
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
                ret.push_back({i, j});
            }
        }
        sort(ret.begin(), ret.end(), [=](vector<int>& a, vector<int>& b) {
            return abs(a[0] - r0) + abs(a[1] - c0) < abs(b[0] - r0) + abs(b[1] - c0);
        });
        return ret;
    }
};
```
2. BFS，广度优先遍历

```python
class Solution:
    def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
        # 四个方位
        dire = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        # 标记是否已经被扩散访问过
        signed = [[False] * C for _ in range(R)]
        
        queue = collections.deque()
        # 添加起始点
        queue.append([r0, c0])
        # 标记已扩散
        signed[r0][c0] = True

        res = []
        while queue:
            # 出列，准备扩散
            cur =  queue.popleft()
            res.append(cur)

            r, c = cur
            # 开始往四周扩散
            for _ in range(4):
                for i, j in dire:
                    nr = r + i
                    nc = c + j
                    # 注意边界，以及是否被扩散访问过
                    if 0 <= nr < R and 0 <= nc < C and not signed[nr][nc]:
                        queue.append([nr, nc])
                        signed[nr][nc] = True
            
        return res
```
