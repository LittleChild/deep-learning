1. **1. 两数之和**
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

方法：
1. 暴力求解，超内存；
2. hash方法，一边遍历，一边建立hash表，这样后面再次判断的时候，先查表，在决定是否继续遍历。
代码：
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
```

2. **402. 移掉K位数字**
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

方法：
遍历k次，每次从左找到第一个比后一位大的数，删掉 代码：
```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        if(num.length()==k)
            return "0";
        int count=0;
        //给字符串加一个末尾0，便于遍历。
        num+="0";
        while (count<k)
        {
            for(int i=0;i<num.length();i++){
                if(int(num[i])>int(num[i+1])){
                    count++;
                    num.erase(i,1);
                    break;
                }
            }
        }
        //记得删除末尾加的0
        num.pop_back();
        //去掉首个‘0’
        while(num.length()>1 && num[0]=='0')
            num.erase(0,1);
        return num;
    }
```

3. **406. 根据身高重建队列**
假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

示例

输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]

方法：非常妙~~~~~
先排个序，按照身高从高到低、k值从低到高排序一下，这样再逐个遍历元素，插入结果中，这时候不用考虑身高问题，直接根据k值和结果长度进行比较，就可以直接知道应该插入在哪个位置了。
参考：https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/
代码：
```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        res = []
        people = sorted(people, key = lambda x: (-x[0], x[1]))
        for p in people:
            if len(res) <= p[1]:
                res.append(p)
            elif len(res) > p[1]:
                res.insert(p[1], p)
        return res
```
4. **2. 两数相加**
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

方法：
模拟相加，维护进位，注意链表可以不等长

代码：
```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode head;
        ListNode *p=&head;
        int bit=0;
        while(l1 || l2){
            int s=bit;
            if(l1)
                s+=l1->val;
            if(l2)
                s+=l2->val;
            if(s>9){
                s-=10;
                bit=1;
            }
            else{
                bit=0;
            }
            ListNode *t=new ListNode(s);
            p->next=t;
            p=p->next;
            if(l1)
                l1=l1->next;
            if(l2)
                l2=l2->next;
        }
        if(bit){
            ListNode *t=new ListNode(bit);
            p->next=t;
        }
        p=&head;
        return p->next;
    }
};
```

5. **1030. 距离顺序排列矩阵单元格**
给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 <= r < R 且 0 <= c < C。

另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。

返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）

方法：
1. 直接都求出距离，然后排序

```c++
class Solution {
public:
    vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0) {
        vector<vector<int>> ret;
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
                ret.push_back({i, j});
            }
        }
        sort(ret.begin(), ret.end(), [=](vector<int>& a, vector<int>& b) {
            return abs(a[0] - r0) + abs(a[1] - c0) < abs(b[0] - r0) + abs(b[1] - c0);
        });
        return ret;
    }
};
```
2. BFS，广度优先遍历

```python
class Solution:
    def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
        # 四个方位
        dire = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        # 标记是否已经被扩散访问过
        signed = [[False] * C for _ in range(R)]
        
        queue = collections.deque()
        # 添加起始点
        queue.append([r0, c0])
        # 标记已扩散
        signed[r0][c0] = True

        res = []
        while queue:
            # 出列，准备扩散
            cur =  queue.popleft()
            res.append(cur)

            r, c = cur
            # 开始往四周扩散
            for _ in range(4):
                for i, j in dire:
                    nr = r + i
                    nc = c + j
                    # 注意边界，以及是否被扩散访问过
                    if 0 <= nr < R and 0 <= nc < C and not signed[nr][nc]:
                        queue.append([nr, nc])
                        signed[nr][nc] = True
            
        return res
```

6. **283. 移动零**
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

方法：

1. 暴力求解：简单的按照原题来，从第一位往后找到第一个不为零的进行交换，然后继续遍历，直到结束，这里要考虑的是减少遍历的次数，就是有时候到中间就已经移动完了。

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.size()==1)
            return;
        int t=0;
        int count=0;
        for(int i=0;i<nums.size();i++){
// 这里我是这样判断的，就是记下有多少个零，但这里的计数有重复情况，我是做了最坏打算，应该可以算出一个更好的较优平均值，来减少最后要遍历的次数。
            if(i>=(nums.size()-(count/(i+1))))
                break;
            if(nums[i]==0){
                count++;
                int j=i+1;
                while (t==0)
                {
                    if(j>=nums.size())
                            break;
                    if(nums[j]!=0){
                        nums[i]=nums[j];
                        nums[j]=0;
                        t=1;
                    }
                    else j++;  
                }
                t=0;    
            }
        }
    }
};
```

2. 不管零，直接找到非零项，最后给尾巴附零
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i = 0,j = 0;
        for(i = 0 ; i < nums.size(); i++)
        {
            if(nums[i] != 0)
            {
                nums[j++] = nums[i];
            }
        }
        while(j < nums.size())
        {
            nums[j++] = 0;
        }
    }
};
```


7.**147. 对链表进行插入排序**
对链表进行插入排序。
从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。

插入排序算法：

插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。

示例 1：

输入: 4->2->1->3
输出: 1->2->3->4

方法：按照题意，每次找到插入位置，插入。

```c++
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode* result=new ListNode(-1);
        ListNode* cur=head;
        ListNode* tail=cur;
        if(head==NULL)
            return head;
        while (head)
        {
            cur=result;
            while (cur->next && cur->next->val<head->val)
            {
                cur=cur->next;
            }
            tail=head;
            head=head->next;
            tail->next=cur->next;
            cur->next=tail;
        }
        return result->next;
    }
};
```

8. **242. 有效的字母异位词**

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true

方法：
根据题意，统计出现字母个数，判断是否一样。除了数组，也可以用map。
```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int count[27]={0};
        int count2[27]={0};
        for(int i=0;i<s.length();i++){
            count[int(s[i])-97]++;
        }
        for(int i=0;i<t.length();i++){
            count2[int(t[i])-97]++;
        }
        for(int i=0;i<27;i++){
            if(count[i]!=count2[i])
                return false;
        }
        return true;
    }
};
```
节约一下，一个计数就行。一次加一次减。
```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int count[27]={0};
        // int count2[27]={0};
        
        for(int i=0;i<s.length();i++){
            count[int(s[i])-97]++;
        }
        for(int i=0;i<t.length();i++){
            count[int(t[i])-97]--;
        }
        for(int i=0;i<27;i++){
            if(count[i]!=0)
                return false;
        }
        return true;
    }
};
```

9. **7. 整数反转**
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

方法：主要是超过范围如何表示，int型4个字节，就是32位的，所以用long long。

速查表：
char             -128 ~ +127        (1 Byte)
short             -32767 ~ + 32768    (2 Bytes)
unsigned short     0 ~ 65536        (2 Bytes)
int             -2147483648 ~ +2147483647   (4 Bytes)
unsigned int         0 ~ 4294967295    (4 Bytes)
long == int
long long         -9223372036854775808 ~ +9223372036854775807    (8 Bytes)
double         1.7 * 10^308        (8 Bytes)

```c++
class Solution {
public:
    int reverse(int x) {
        if(x<10 && x>-10)
            return x;
        long long re=0;
        while (x)
        {
            int t=x%10;
            x=int(x/10);
            if(re*10+t>pow(2,31) || re*10+t<-1*pow(2,31))
                return 0;
            re=re*10+t;
            
        }
        return re;
    }
};
```
10. **164. 最大间距**

给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。

方法：1. 简单，先排序，在遍历
```c++
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        if(nums.size()<2)
            return 0;
        sort(nums.begin(),nums.end());
        int max=0;
        for(int i=0;i<nums.size()-1;i++){
            if(nums[i+1]-nums[i]>max){
                max=nums[i+1]-nums[i];
            }
        }
        return max;
    }
};
```
2.桶排序
。。。。。。

11. **454. 四数相加 II**
给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 

方法：
尽量减少循环嵌套，采用空间换时间，直观暴力求解是N的4次方，现在直接砍掉一半，考虑A和B的和与C和D的和是否为相反数，然后空间换时间，用最大的500*500的数组存储结果，然后用map记录计算结果和频次，遍历map得到结果。

```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        int L=A.size();
        map<int,int>m1;
        map<int,int>m2;
        int *c1=new int[L*L];
        int *c2=new int[L*L];
        for(int i=0;i<L;i++){
            for(int j=0;j<L;j++){
                c1[i+j*L]=A[i];
                c1[i+j*L]+=B[j];
                c2[i+j*L]=C[i];
                c2[i+j*L]+=D[j];
                // cout<<c1[i+j*L]<<' '<<c2[i+j*L]<<endl;
                m1[c1[i+j*L]]++;
                m2[c2[i+j*L]]++;
            }
        }
        int re=0;
        for(map<int,int>::reverse_iterator iter=m1.rbegin();iter!=m1.rend();iter++){
            if(m2[-(iter->first)]){
                re+=(m2[-(iter->first)]*iter->second);
                // cout<<m2[-(iter->first)]<<endl;
                // cout<<iter->first<<" "<<iter->second<<endl;
            }
        }
        return re;
    }
};
// 采用智能指针的写法，精简一下
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> countAB;
        for (int u: A) {
            for (int v: B) {
                ++countAB[u + v];
            }
        }
        int ans = 0;
        for (int u: C) {
            for (int v: D) {
                if (countAB.count(-u - v)) {
                    ans += countAB[-u - v];
                }
            }
        }
        return ans;
    }
};
```

12. **976. 三角形的最大周长**
给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。

如果不能形成任何面积不为零的三角形，返回 0。

方法：
排序，遍历。
```c++
class Solution {
public:
    int largestPerimeter(vector<int>& A) {
        sort(A.begin(),A.end());
        for(int i=A.size()-1;i>1;i--){
            if(A[i]<A[i-1]+A[i-2]){
                return (A[i]+A[i-1]+A[i-2]);
            }
        }
        return 0;

    }
};
```

13. **767. 重构字符串**
给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。

若可行，输出任意可行的结果。若不可行，返回空字符串。

方法：不会写，看的官方解答，判断解存在比较简单，给出一个解有点麻烦。基于最大堆的贪心，用queue实现。

```c++
class Solution {
public:
    string reorganizeString(string S) {

        if (S.length() < 2) {
            return S;
        }
        vector<int> counts(26, 0);
        int maxCount = 0;
        int length = S.length();
        for (int i = 0; i < length; i++) {
            char c = S[i];
            counts[c - 'a']++;
            maxCount = max(maxCount, counts[c - 'a']);
        }
        if (maxCount > (length + 1) / 2) {
            return "";
        }
        auto cmp = [&](const char& letter1, const char& letter2) {
            return counts[letter1 - 'a']  < counts[letter2 - 'a'];
        };
        priority_queue<char, vector<char>,  decltype(cmp)> queue{cmp};
        for (char c = 'a'; c <= 'z'; c++) {
            if (counts[c - 'a'] > 0) {
                queue.push(c);
            }
        }
        string sb = "";
        while (queue.size() > 1) {
            char letter1 = queue.top(); queue.pop();
            char letter2 = queue.top(); queue.pop();
            sb += letter1;
            sb += letter2;
            int index1 = letter1 - 'a', index2 = letter2 - 'a';
            counts[index1]--;
            counts[index2]--;
            if (counts[index1] > 0) {
                queue.push(letter1);
            }
            if (counts[index2] > 0) {
                queue.push(letter2);
            }
        }
        if (queue.size() > 0) {
            sb += queue.top();
        }
        return sb;
    }
};
```

14. **34. 在排序数组中查找元素的第一个和最后一个位置**
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

方法：
1) 简单粗暴，直接遍历。
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int l=nums.size();
        if(l==0)
            return {-1,-1};
        vector<int>re;
        bool is=false;
        //末尾添加一个最值，便于结束判断
        nums.push_back(pow(10,9));
        l++;
        for(int i=0;i<l;i++){
            if(nums[i]==target&&!is){
                re.push_back(i);
                is=true;
            }
            else if(nums[i]!=target&&is){
                re.push_back(i-1);
                is=false;
                break;
            }
        }
        if(re.size()==0){
            return {-1,-1};
        }
        else if(re.size()==1)
        {
            re.push_back(re[0]);
        }
        return re;
    }
};
```
2） 很容易就想到二分法，先找左边界，再找右边界。注意的是，他跟二分搜索有不一样的地方，就是在于找到元素相等的情况下，继续搜索。
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> res(2,-1);
        if(nums.empty()) return res;
        int n=nums.size(),l=0,r=n-1;
        while(l<r){
            int m=l+(r-l)/2;
            if(nums[m]>=target) r=m;
            else l=m+1;
        }
        if(nums[l]!=target) return res;
        res[0]=l;
        r=n;
        while(l<r){
            int m=l+(r-l)/2;
            if(nums[m]<=target) l=m+1;
            else r=m;
        }
        res[1]=l-1;
        return res;
    }
};
```

15. **204. 计数质数**
统计所有小于非负整数 n 的质数的数量。

方法：
1）穷举，但是减少穷举范围，考虑到如果 y 是 x 的因数，那么x/y也必然是x的因数，因此我们只要校验y或者x/y即可。而如果我们每次选择校验两者中的较小数，则不难发现较小数一定落在 [2,\sqrt{x}]的区间中，因此我们只需要枚举[2,\sqrt{x}]中的所有数即可，这样单次检查的时间复杂度从 O(n)降低至了 O(\sqrt{n}).

```c++
class Solution {
public:
    int countPrimes(int n) {
        int re=0;
        if(n<=2)
            return 0;
        n--;
        while(n>1)
        {
            for(int i=2;i*i<=n;i++){
                if(n%i==0){
                    re--;
                    break;
                }
            }
            re++;
            n--;
        }
        return re;
    }
};
```
2)埃氏筛，就是用一个状态量表示是否为质数，同时x为质数，则x的倍数为合数。
```c++
class Solution {
public:
    int countPrimes(int n) {
        vector<int> isPrime(n, 1);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i]) {
                ans += 1;
                if ((long long)i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = 0;
                    }
                }
            }
        }
        return ans;
    }
};
```

16. **9. 回文数** 
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

方法：转成字符串首尾挨个判断
```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0)  
            return false;
        string ss=to_string(x);
        int i=0,j=ss.length()-1;
        while(i<j){
            if(ss[i]!=ss[j])
                return 0;
            i++;
            j--;
        }
        return 1;
    }
};
```

17. **118. 杨辉三角**

给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

方法：
按照杨辉三角的算法，逐行计算,按照上一层到这一层的递推式
```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<int>p={1};
        vector<vector<int>>re;
        if(numRows==0)
            return re;
        re.push_back(p);
        if(numRows==1)
            return re;
        p.push_back(1);
        re.push_back(p);
        if(numRows==2)
            return re;
        vector<int>t;
        for(int i=1;i<numRows-1;i++){
            t.push_back(1);
            for(int j=0;j<i;j++){
                t.push_back(p[j]+p[j+1]);
            }
            t.push_back(1);
            re.push_back(t);
            p=t;
            t.clear();
        }
        return re;
    }
};
//或者
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> ret(numRows);
        for (int i = 0; i < numRows; ++i) {
            ret[i].resize(i + 1);
            ret[i][0] = ret[i][i] = 1;
            for (int j = 1; j < i; ++j) {
                ret[i][j] = ret[i - 1][j] + ret[i - 1][j - 1];
            }
        }
        return ret;
    }
};

```

18. **842. 将数组拆分成斐波那契序列**
给定一个数字字符串 S，比如 S = "123456579"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。

方法：回溯+剪枝
```c++
class Solution {
public:
    vector<int> ans;
    vector<int> splitIntoFibonacci(string S) {
        const int n = S.length();
        backtracking(0,n,S);
        return ans; 
    };
    bool backtracking(int p,int n,string S) {
        if (p == n) return ans.size() > 2;
        long num = 0;
        int max_len = S[p] == '0' ? 1 : 10;
        for (int i = p; i < min(p + max_len, n); ++i) {
            num = num * 10 + S[i] - '0';
            if (num > INT_MAX) break; // prunning ...
            if (ans.size() >= 2) {
            long sum = ans.rbegin()[0];
            sum += ans.rbegin()[1];
            if (num > sum) break; // pruning ...
            else if (num < sum) continue;
            // num must equals to s
            }
            ans.emplace_back(num);
            if (backtracking(i + 1,n,S)) return true;;
            ans.pop_back();
        }
        return false;
    };
};
```

19. **860. 柠檬水找零**

方法：模拟一遍，暴力求解。
```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int cash[2]={0};
        for(int i = 0; i<bills.size();i++){
            if (bills[i]==5){
                cash[0]++;
            }
            else if(bills[i]==10){
                cash[1]++;
                if(cash[0])
                    cash[0]--;
                else
                    return false;
            }
            else if(cash[1])
            {
                cash[1]--;
                cash[0]--;
            }
            else cash[0]-=3;
            if(cash[0]<0) return false;
        }
        return true;
    }
};
```

20. **217. 存在重复元素**
给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

方法：字典存储计数，遍历判断
```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        map<int,int>m;
        for(int i=0;i<nums.size();i++){
            m[nums[i]]++;
        }
        for(map<int,int>::iterator it=m.begain();it!=m.end();it++){
            if(it->second>1)
                return false;
        }
        return true;
    }
};
```

21. **738. 单调递增的数字**

给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

方法：
不要想复杂，思路很简单，向前遍历，前一项大于后一项，前一项就减1，后面所有都变成9
```c++
class Solution {
public:
    int monotoneIncreasingDigits(int N) {
        int i = 1;
        int res = N;
        while(i <= res/10) {
            int n = res / i % 100; // 每次取两个位
            i *= 10;
            if(n/10 > n%10) // 比较的高一位大于底一位
                res = res / i * i - 1; //例如1332 循环第一次变为1330-1=1329 第二次变为1300-1=1299
        }
        return res;
    }
};
```

22. **48. 旋转图像**

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

方法：最简单的是，先上下颠倒，再转置。

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n=matrix.size();
        for(int i=0;i<n/2;i++){
            matrix[i].swap(matrix[n-1-i]);
        }
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                int t=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=t;
             }
         }

//or 
        // int n = matrix.size();
        // for(int i = 0; i < n / 2; i++) matrix[i].swap(matrix[n - 1 - i]);
        // for(int i = 0; i < n; i++) {
        //     for(int j = i; j < n; j++) { 
        //         swap(matrix[i][j], matrix[j][i]);
        //     }
        // }
    }
};
```

23. **316. 去除重复字母 / 1081. 不同字符的最小子序列**

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

方法：贪心+栈.
```c++
class Solution {
public:
    string removeDuplicateLetters(string s) {
        string re;
        int map[26]={0},vis[26]={0};
        // map记录s的字母出现次数，vis记录栈中是否存在，即判断是否是新字母
        for(int i=0;i<s.length();i++){
            map[int(s[i])-int('a')]++;  
        }
        for(char ch:s){
            if(!vis[ch-'a']){
                while(!re.empty() && re.back() > ch){
                // 如果栈顶元素的字典序比新的字母大，看其是否有多个，考虑删掉
                    if(map[re.back()-'a']){
                        vis[re.back()-'a']=0;
                        re.pop_back();
                    }
                    else
                    {
                        break;
                    }
                }
                // 新字母进栈
                vis[ch-'a']=1;
                re.push_back(ch);
            }
            // 进栈后要map计数减1
            map[ch-'a']--;
        }
        return re;
    }
};
```

24. **746. 使用最小花费爬楼梯**

数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

方法：1)到达当前台阶时判断下从前一个台阶过来省事，还是从前一个的前一个过来省事，一直累加到最后一个台阶完，最小值就是最省体力的。 用s1和s2表示前两个和前一个台阶所耗费的体力，一遍循环就可以了。
```c++
class Solution {
public:
    int dic[1000]={0};
    int minCostClimbingStairs(vector<int>& cost) {
        int s1=0;
        int s2=0;
        int i=2;
        while(i<=cost.size()){
            int t=s1;
            s1=s2;
            s2=min(s2 + cost[i-1], t + cost[i-2]);
            i++;
        }
        return s2; 
    }
```
2)dp
```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp[10001]={0};
        int l= cost.size();
        for(int i=2;i<=l;i++){
            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        return dp[l-1];
    }
}
// or
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int l= cost.size();
        for(int i=2;i<l;i++){
            cost[i]+=min(cost[i-1],cost[i-2]);
        }
        return min(cost[l-1],cost[l-2]);
    }
};
```
25. **103. 二叉树的锯齿形层序遍历**
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）

方法：借用队列进行层序遍历
```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>>re;
        if(root==NULL)
            return re;
        queue<TreeNode*>q;
        queue<TreeNode*>q2;
        q.push(root);
        int i=0;
        // while(!q.empty())
        // {
        //     //一次性将一整行的节点全部都遍历完
        //     vector<int> level;
        //     size_t levelsize = q.size();
        //     for(size_t j=0;j<levelsize;++j)
        //     {
        //         TreeNode* cur = q.front();
        //         level.push_back(cur->val);
        //         //如果存在左孩子，将其入队列
        //         if(cur->left)
        //         q.push(cur->left);
        //         //如果存在右孩子，将其入队列
        //         if(cur->right)
        //         q.push(cur->right);
        //         q.pop();
        //     }
        //     if(i%2==0)
        //         re.push_back(level);
        //     else{
        //         reverse(level.begin(),level.end());
        //         re.push_back(level);
        //     }
        // }
        while(!q.empty()||!q2.empty()){
            vector<int>temp;
            if(i%2==0){
                while(!q.empty()){
                    TreeNode* t=q.front();
                    temp.push_back(t->val);
                    if(t->left)
                    q2.push(t->left);
                    if(t->right)
                    q2.push(t->right);
                    q.pop();
                }
            }
            else{
                while(!q2.empty()){
                    TreeNode* t=q2.front();
                    temp.push_back(t->val);
                    if(t->left)
                    q.push(t->left);
                    if(t->right)
                    q.push(t->right);
                    q2.pop();
                }
                reverse(temp.begin(),temp.end());
            }
            i++;
            re.push_back(temp);
        }
        return re;
    }
};
```
26. **387. 字符串中的第一个唯一字符**

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

方法：简单遍历计数，输出第一个计数为1的下标。
```c++
class Solution {
public:
    int firstUniqChar(string s) {
        int map[26]={0};
        for(int i=0;i<s.length();i++){
            map[(s[i]-'a')]++;
        }
        for(int i=0;i<s.length();i++){
            if(map[(s[i]-'a')]==1)
                return i;
        }
        return -1;
    }
};
```

27. **135. 分发糖果**
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

a)每个孩子至少分配到 1 个糖果。
b)相邻的孩子中，评分高的孩子必须获得更多的糖果。

方法：
两次遍历

我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。

左规则：当 ratings[i - 1] < ratings}[i] 时，i 号学生的糖果数量将比 i−1 号孩子的糖果数量多。

右规则：当 ratings[i] > ratings[i + 1] 时，i 号学生的糖果数量将比 i+1 号孩子的糖果数量多。

我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int re=ratings.size();
        int *l=new int[re];
        int *r=new int[re];
        if(re<=1) 
            return re;
        for(int i=0;i<ratings.size();i++){
            if(i>0 &&ratings[i]>ratings[i-1]){
                l[i]=l[i-1]+1;
            }else
            {
                l[i]=1;
            }
        }
        re=0;
        for(int i=ratings.size()-1;i>=0;i--){
            if(i<ratings.size()-1 &&ratings[i]>ratings[i+1]){
                r[i]=r[i+1]+1;
            }else
            {
                r[i]=1;
            }
            re+=max(l[i],r[i]);
        }
        return re;
    }
};
```

28. **330. 按要求补齐数组**

给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

示例：

输入: nums = [1,3], n = 6

输出: 1 

解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。

方法：
首先需要明确一个规律(官方题解有证明):假设某个区间包含从1到x的所有数，不包含x，称为覆盖区间，记为[1,x)，若我们将x添加到该区间，则原来区间可以覆盖的数的区间会扩大到[1,2x)。 
（其实就是区间平移x，比如[1,3)，加入3后就等于把原来区间内所有数都加3，因此区间扩大到[1,6)）

然后贪心，，，，，，拍脑袋吧
```C++
class Solution {
public:
    int minPatches(vector<int>& nums, int n) {
        long int miss=1;//覆盖区间的右端点
        int idx=0;//当前遍历到的数组元素的下标
        int re=0;//我们需要手动添加数字扩展覆盖区间的个数
        while(miss<=n){//结束条件为覆盖区间大于n
            if(idx<nums.size() && nums[idx]<=miss){
                miss+=nums[idx];
                idx+=1;
            }
            else{
                miss+=miss;
                re+=1;
            }
        }
        return re;
    }
};
```

29. **803. 打砖块**

题目：……

方法：

1）逆序+并查集

2）逆序思维，倒着来，然后一个一个找

```python
class Solution:
    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:
        res = [] # 存储结果的列表
        current = 0 # 稳定的砖块的数量
        # 先敲掉砖块
        for i, j in hits:
            grid[i][j] -= 1
        # 初始化(标记稳定的砖块)
        for j in range(len(grid[0])):
            visit(0, j, grid)
        # 从后往前恢复砖块
        for i in range(len(hits)-1, -1, -1):
            x, y = hits[i][0], hits[i][1]
            grid[x][y] += 1 # 恢复砖块
            # 敲掉的位置原本就不是砖块，掉落0个
            if not grid[x][y]:
                res.append(0)
                continue
            # 没有直接或间接与顶部相连，即不是稳定的砖块(和它相邻的必然也不是稳定的，故掉落0个)
            if x != 0 and not judge(x-1, y, grid) + judge(x+1, y, grid) + judge(x, y-1, grid) + judge(x, y+1, grid):
                res.append(0)
                continue
            current = visit(x, y, grid) # 与当前位置相连接的稳定的砖块数量
            res.append(current - 1) # 减1是减去自身
        res.reverse()
        return res

def visit(i, j, grid) -> int:
    # 非法的坐标或者当前位置不是砖块，返回0，即没有稳定的砖块
    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:
        return 0
    grid[i][j] += 1 # 标记一下该砖块是不是稳定的
    return visit(i-1, j, grid) + visit(i+1, j, grid) + visit(i, j-1, grid) + visit(i, j+1, grid) + 1

# 判断该位置是不是稳定的砖块
def judge(i, j, grid) -> int:
    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 2:
        return 1
    return 0
```

30. **1232. 缀点成线**

题目：判断点是否共线

方法：

1）斜率，两两比较，判断

2）斜率不存在怎么办，不好求。用三点式，一次判断3点共线，把斜率式子改一下，把分母移上来，变成 (x1-x2)*(y2-y3)=(x2-x3)*(y1-y2)
```c++
class Solution {
public:
    bool checkStraightLine(vector<vector<int>>& coordinates) {
        if(coordinates.size()==2)
            return true;
        for(int i=0;i<coordinates.size()-2;i++){
            if ((coordinates[i][0]-coordinates[i+1][0])*(coordinates[i+1][1]-coordinates[i+2][1]) != (coordinates[i][1]-coordinates[i+1][1])*(coordinates[i+1][0]-coordinates[i+2][0]))
                return false;
        }
        return true;
    }
};
```

31. **674. 最长连续递增序列**

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

方法：一次遍历，记录最大长度。
```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size()==0)
            return 0;
        int max=1;
        int premax=1;
        for(int i=1;i<nums.size();i++){
            if(nums[i]>nums[i-1]){
                max+=1;
            }
            else{
                if(max>premax){
                    premax=max;
                }
                max=1;
            }
        }
        return premax>max?premax:max;
    }
};
```

32. **1579. 保证图可完全遍历**

题目：...

方法：并查集！！！！！
```c++
class Solution {
public:
    vector<int> par;
    int cnt;
    int getRoot(int x){
        int root = x;
        while(par[root]!=root){
            root = par[root];
        }
        while(par[x]!=root){
            int tmp = par[x];
            par[x] = root;
            x = tmp;
        }
        return root;
    }
    void merge(int x,int y){
        int _x = getRoot(x);
        int _y = getRoot(y);
        if(_x!=_y){
            par[_x]=_y;
            cnt--;
        }
    }
    //初始化
    void init(int n){
        //cnt为集合个数，初始化每个结点视为一个集合
        cnt = n;
        for(int i =1;i<=n;i++){
            par[i] = i;
        }
    }
    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {
        par = vector<int>(n+1,0);
        int ans = 0;
        //分别存储第一种到第三种类型的边
        int cnt1 = 0,cnt2 = 0,cnt3 = 0;
        init(n);
        //判断对于Alice是否连通
        for(int i = 0;i<edges.size();i++){
            if(edges[i][0]==1||edges[i][0]==3){
                merge(edges[i][1],edges[i][2]);
                cnt1++;
            }
        }
        if(cnt!=1)
            return -1;
        init(n);
        //判断对于Bob是否连通
        for(int i = 0;i<edges.size();i++){
            if(edges[i][0]==2||edges[i][0]==3){
                merge(edges[i][1],edges[i][2]);
                cnt2++;
            }
        }
        if(cnt!=1)
            return -1;
        init(n);
        //添加第三种类型的边
        for(int i = 0;i<edges.size();i++){
            if(edges[i][0]==3){
                merge(edges[i][1],edges[i][2]);
                cnt3++;
            }
        }
        //去除第三种类型的边
        cnt1-=cnt3;
        cnt2-=cnt3;
        //多余的第三种类型的边
        ans+=(cnt3-(n-cnt));
        //多余的其余两种类型的边
        ans += cnt1-(cnt-1)+cnt2-(cnt-1);
        
        return ans;
    }
};

```