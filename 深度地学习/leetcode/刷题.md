1. **1. 两数之和**
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

方法：
1. 暴力求解，超内存；
2. hash方法，一边遍历，一边建立hash表，这样后面再次判断的时候，先查表，在决定是否继续遍历。
代码：
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
```

2. **402. 移掉K位数字**
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

方法：
遍历k次，每次从左找到第一个比后一位大的数，删掉 代码：
```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        if(num.length()==k)
            return "0";
        int count=0;
        //给字符串加一个末尾0，便于遍历。
        num+="0";
        while (count<k)
        {
            for(int i=0;i<num.length();i++){
                if(int(num[i])>int(num[i+1])){
                    count++;
                    num.erase(i,1);
                    break;
                }
            }
        }
        //记得删除末尾加的0
        num.pop_back();
        //去掉首个‘0’
        while(num.length()>1 && num[0]=='0')
            num.erase(0,1);
        return num;
    }
```

3. **406. 根据身高重建队列**
假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

示例

输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]

方法：非常妙~~~~~
先排个序，按照身高从高到低、k值从低到高排序一下，这样再逐个遍历元素，插入结果中，这时候不用考虑身高问题，直接根据k值和结果长度进行比较，就可以直接知道应该插入在哪个位置了。
参考：https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/
代码：
```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        res = []
        people = sorted(people, key = lambda x: (-x[0], x[1]))
        for p in people:
            if len(res) <= p[1]:
                res.append(p)
            elif len(res) > p[1]:
                res.insert(p[1], p)
        return res
```
4. **2. 两数相加**
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

方法：
模拟相加，维护进位，注意链表可以不等长

代码：
```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode head;
        ListNode *p=&head;
        int bit=0;
        while(l1 || l2){
            int s=bit;
            if(l1)
                s+=l1->val;
            if(l2)
                s+=l2->val;
            if(s>9){
                s-=10;
                bit=1;
            }
            else{
                bit=0;
            }
            ListNode *t=new ListNode(s);
            p->next=t;
            p=p->next;
            if(l1)
                l1=l1->next;
            if(l2)
                l2=l2->next;
        }
        if(bit){
            ListNode *t=new ListNode(bit);
            p->next=t;
        }
        p=&head;
        return p->next;
    }
};
```

5. **1030. 距离顺序排列矩阵单元格**
给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 <= r < R 且 0 <= c < C。

另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。

返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）

方法：
1. 直接都求出距离，然后排序

```c++
class Solution {
public:
    vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0) {
        vector<vector<int>> ret;
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
                ret.push_back({i, j});
            }
        }
        sort(ret.begin(), ret.end(), [=](vector<int>& a, vector<int>& b) {
            return abs(a[0] - r0) + abs(a[1] - c0) < abs(b[0] - r0) + abs(b[1] - c0);
        });
        return ret;
    }
};
```
2. BFS，广度优先遍历

```python
class Solution:
    def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
        # 四个方位
        dire = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        # 标记是否已经被扩散访问过
        signed = [[False] * C for _ in range(R)]
        
        queue = collections.deque()
        # 添加起始点
        queue.append([r0, c0])
        # 标记已扩散
        signed[r0][c0] = True

        res = []
        while queue:
            # 出列，准备扩散
            cur =  queue.popleft()
            res.append(cur)

            r, c = cur
            # 开始往四周扩散
            for _ in range(4):
                for i, j in dire:
                    nr = r + i
                    nc = c + j
                    # 注意边界，以及是否被扩散访问过
                    if 0 <= nr < R and 0 <= nc < C and not signed[nr][nc]:
                        queue.append([nr, nc])
                        signed[nr][nc] = True
            
        return res
```

6. **283. 移动零**
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

方法：

1. 暴力求解：简单的按照原题来，从第一位往后找到第一个不为零的进行交换，然后继续遍历，直到结束，这里要考虑的是减少遍历的次数，就是有时候到中间就已经移动完了。

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.size()==1)
            return;
        int t=0;
        int count=0;
        for(int i=0;i<nums.size();i++){
// 这里我是这样判断的，就是记下有多少个零，但这里的计数有重复情况，我是做了最坏打算，应该可以算出一个更好的较优平均值，来减少最后要遍历的次数。
            if(i>=(nums.size()-(count/(i+1))))
                break;
            if(nums[i]==0){
                count++;
                int j=i+1;
                while (t==0)
                {
                    if(j>=nums.size())
                            break;
                    if(nums[j]!=0){
                        nums[i]=nums[j];
                        nums[j]=0;
                        t=1;
                    }
                    else j++;  
                }
                t=0;    
            }
        }
    }
};
```

2. 不管零，直接找到非零项，最后给尾巴附零
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i = 0,j = 0;
        for(i = 0 ; i < nums.size(); i++)
        {
            if(nums[i] != 0)
            {
                nums[j++] = nums[i];
            }
        }
        while(j < nums.size())
        {
            nums[j++] = 0;
        }
    }
};
```


7.**147. 对链表进行插入排序**
对链表进行插入排序。
从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。

插入排序算法：

插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。

示例 1：

输入: 4->2->1->3
输出: 1->2->3->4

方法：按照题意，每次找到插入位置，插入。

```c++
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode* result=new ListNode(-1);
        ListNode* cur=head;
        ListNode* tail=cur;
        if(head==NULL)
            return head;
        while (head)
        {
            cur=result;
            while (cur->next && cur->next->val<head->val)
            {
                cur=cur->next;
            }
            tail=head;
            head=head->next;
            tail->next=cur->next;
            cur->next=tail;
        }
        return result->next;
    }
};
```

8. **242. 有效的字母异位词**

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true

方法：
根据题意，统计出现字母个数，判断是否一样。除了数组，也可以用map。
```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int count[27]={0};
        int count2[27]={0};
        for(int i=0;i<s.length();i++){
            count[int(s[i])-97]++;
        }
        for(int i=0;i<t.length();i++){
            count2[int(t[i])-97]++;
        }
        for(int i=0;i<27;i++){
            if(count[i]!=count2[i])
                return false;
        }
        return true;
    }
};
```
节约一下，一个计数就行。一次加一次减。
```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int count[27]={0};
        // int count2[27]={0};
        
        for(int i=0;i<s.length();i++){
            count[int(s[i])-97]++;
        }
        for(int i=0;i<t.length();i++){
            count[int(t[i])-97]--;
        }
        for(int i=0;i<27;i++){
            if(count[i]!=0)
                return false;
        }
        return true;
    }
};
```

9. **7. 整数反转**
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

方法：主要是超过范围如何表示，int型4个字节，就是32位的，所以用long long。

速查表：
char             -128 ~ +127        (1 Byte)
short             -32767 ~ + 32768    (2 Bytes)
unsigned short     0 ~ 65536        (2 Bytes)
int             -2147483648 ~ +2147483647   (4 Bytes)
unsigned int         0 ~ 4294967295    (4 Bytes)
long == int
long long         -9223372036854775808 ~ +9223372036854775807    (8 Bytes)
double         1.7 * 10^308        (8 Bytes)

```c++
class Solution {
public:
    int reverse(int x) {
        if(x<10 && x>-10)
            return x;
        long long re=0;
        while (x)
        {
            int t=x%10;
            x=int(x/10);
            if(re*10+t>pow(2,31) || re*10+t<-1*pow(2,31))
                return 0;
            re=re*10+t;
            
        }
        return re;
    }
};
```
