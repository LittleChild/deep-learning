## 刷题

### **nowcoder**

JZ4：重建二叉树

题解：就是根据前序和中序遍历的结果，重建二叉树。

方法：首先要吧遍历二叉树的过程给回忆一下

前序：根——>左——>右，

中序：左——>根——>右

后序：左——>右——>根

显然，前序的话，根节点一定是第一个，中序的话一定是在中间，然后中序的话根的左边是左子树，右边是右子树，所以显然用**递归**的话很简单就想到了，按照前序找到根节点，把中序遍历分成左右子树，然后有分别是一样的情况，因为中序遍历的话，子树也是中序遍历的顺序。

```c++
//任201803231505918, 5940473
/*
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
*/
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) {
        return rebuilt(0, 0, pre.size() - 1, pre, vin);
    }
    TreeNode* rebuilt(int prestart, int vinstart, int size, vector<int> pre, vector<int> vin) {
        if (prestart >= pre.size() || vinstart > size) {
            return nullptr;
        }
        TreeNode* root = new TreeNode(pre[prestart]);
        int ii = 0;
        for (int i = vinstart; i <= size; i++) {
            if (pre[prestart] == vin[i]) {
                ii = i;
                break;
            }
        }
        root->left = rebuilt(prestart + 1, vinstart, ii - 1, pre, vin);
        root->right= rebuilt(prestart + 1 + ii - vinstart, ii + 1, size, pre, vin);
        return root;
    }
};
```





JZ21：栈的压入、弹出序列

题解：就是两个序列A，B，判断B是否为A的出栈序列。

方法：模拟A的入栈和出栈，然后以B的元素顺序最为出栈的指导。用一个向量vector当作栈，每次压栈，判断栈顶元素是否跟B的对应序列元素相同，一样就出栈，继续判断，不一样就继续按照A顺序压栈，最后把A的元素压弯，判断栈中元素是否能够都出来，都出来就说明B是一个正确的出栈顺序。

```c++
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        if(pushV.empty()&&popV.empty())
            return true;
        int l=pushV.size();
        vector<int> record;
        int k=0;
        for(int i=0;i<l;i++){
            record.push_back(pushV[i]);
            while(!record.empty()&&record.back()==popV[k]){
                record.pop_back();
                k++;
                }
            }
        if (record.empty())
            return 1;
        else
            return 0;
    }
```



JZ22：从上往下打印二叉树

题意：从上往下打印出二叉树的每个节点，同层节点从左至右打印。

方法：用上队列就很简单了，就是一个层序遍历，这里要注意的是队列的使用方法，先进先出，C++里面queue.pop()是void类型的，没有返回值的，要取队列首位元素需要用到queue.front()，然后别忘了再pop一下。

```c++
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        vector<int>re;
        //第一次提交没有加这个异常检测，没有通过，还是要边界检测呀
        if (root == NULL) {
            return re;
        }
        queue<TreeNode*>q;
        q.push(root);
        while (!q.empty())
        {
            root = q.front();
            q.pop();
            re.push_back(root->val);
            if (root->left != NULL)
                q.push(root->left);
            if (root->right != NULL)
                q.push(root->right);
        }
        return re;
    }
};
```





JZ40: 数组中只出现一次的数字

题意：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

这次是看的网上的解析才懂得（捂脸，太巧妙了）

方法：可以用哈希或者异或的方法，哈希就不多说了，一次遍历map构建一下，计数，二次遍历查数，对应赋值。这里给出一个在下认为最为巧妙的方法，**异或**。

异或的性质：

1. 交换律;
2. 结合律;
3. **a^a=0, a^0=a**, a^(-1)=~a。

所以：对于任意的a，有a^b^c^d^a^k = b^c^d^k^(a^a) = b^c^d^k^0 = b^c^d^k，也就是说，如果有多个数异或，其中有重复的数，则无论这些重复的数是否相邻，都可以根据异或的性质将其这些重复的数消去，具体来说，如果重复出现了偶数次，则异或后会全部消去，如果重复出现了奇数次，则异或后会保留一个。

下面来看两道题目：

1. 1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空间，能否设计一个算法实现？

    当然，这道题，可以用最直观的方法来做，将所有的数加起来，减去1+2+3+...+1000的和，得到的即是重复的那个数，该方法很容易理解，而且效率很高，也不需要辅助空间，唯一的不足时，如果范围不是1000，而是更大的数字，可能会发生溢出。我们考虑用异或操作来解决该问题。现在问题是要求重复的那个数字，我们姑且假设该数字式n吧，如果我们能想办法把1-1000中除n以外的数字全部异或两次，而数字n只异或一次，就可以把1-1000中出n以外的所有数字消去，这样就只剩下n了。我们首先把所有的数字异或，记为T，可以得到如下：

   ​				T = 1^2^3^4...^n...^n...^1000 = 1^2^3...^1000（结果中不含n）

   而后我们再让T与1-1000之间的所有数字（仅包含一个n）异或，便可得到该重复数字n。如下所示：

   ​				T^(a^2^3^4...^n...^1000) = T^(T^n) = 0^n = n

    这道题到此为止。

2. 一个数组中只有一个数字出现了一次，其他的全部出现了两次，求出这个数字。

   明白了上面题目的推导过程，这个就很容易了，将数组中所有的元素全部异或，最后出现两次的元素会全部被消去，而最后会得到该只出现一次的数字。该题目同样可以该为如下情景，思路是一样的：数组中只有一个数字出现了奇数次，其他的都出现了偶数次。

再来看JZ40，

采用同样的方法可以去除掉出现2次的数，但是最后的结果是只出现1次的两个数的异或结果，所以需要把这两个数给分开，怎么分呢？其他的数字其实不用考虑，因为一样的数字哪哪都是有一样的，只需要把那两个只出现1次的不一样的数字分开就行，这里还可以用到前面异或的结果，异或的本质是啥？不就是不一样为1吗，那么只要找到该结果里面一个为1的位（**不用怀疑前面的异或结果找不到1，如果找不到，说明那两个数是一样的，因为相同的数字才会异或结果为0**），不就说明这连个数字在该位上是一个1，一个0吗，然后就按这个标准分成两个数组，分别全部异或一下，不就求出这两个数字了吗。太精妙了。

```c++
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
		if(data.size() < 2) return ;
        int myxor = 0;
        int flag = 1;
        for(int i = 0 ; i < data.size(); ++ i )
            myxor ^= data[i];
        while((myxor & flag) == 0) flag <<= 1;
        //这一步就是找那个1，找到一个就行，随便哪一位，这里是从地位往高位找的。
        *num1 = myxor;
        *num2 = myxor;
        for(int i = 0; i < data.size(); ++ i ){
            //根据找到的那一位1，把数组分成了两个分别全部累计异或
            if((flag & data[i]) == 0) *num2 ^= data[i];
            else *num1 ^= data[i];
        }
    }
};
```

