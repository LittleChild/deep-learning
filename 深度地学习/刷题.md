## 刷题

### **nowcoder**

JZ4：重建二叉树

题解：就是根据前序和中序遍历的结果，重建二叉树。

方法：首先要吧遍历二叉树的过程给回忆一下

前序：根——>左——>右，

中序：左——>根——>右

后序：左——>右——>根

显然，前序的话，根节点一定是第一个，中序的话一定是在中间，然后中序的话根的左边是左子树，右边是右子树，所以显然用**递归**的话很简单就想到了，按照前序找到根节点，把中序遍历分成左右子树，然后有分别是一样的情况，因为中序遍历的话，子树也是中序遍历的顺序。

```c++
//任201803231505918, 5940473
/*
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
*/
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) {
        return rebuilt(0, 0, pre.size() - 1, pre, vin);
    }
    TreeNode* rebuilt(int prestart, int vinstart, int size, vector<int> pre, vector<int> vin) {
        if (prestart >= pre.size() || vinstart > size) {
            return nullptr;
        }
        TreeNode* root = new TreeNode(pre[prestart]);
        int ii = 0;
        for (int i = vinstart; i <= size; i++) {
            if (pre[prestart] == vin[i]) {
                ii = i;
                break;
            }
        }
        root->left = rebuilt(prestart + 1, vinstart, ii - 1, pre, vin);
        root->right= rebuilt(prestart + 1 + ii - vinstart, ii + 1, size, pre, vin);
        return root;
    }
};
```





JZ21：栈的压入、弹出序列

题解：就是两个序列A，B，判断B是否为A的出栈序列。

方法：模拟A的入栈和出栈，然后以B的元素顺序最为出栈的指导。用一个向量vector当作栈，每次压栈，判断栈顶元素是否跟B的对应序列元素相同，一样就出栈，继续判断，不一样就继续按照A顺序压栈，最后把A的元素压弯，判断栈中元素是否能够都出来，都出来就说明B是一个正确的出栈顺序。

```c++
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        if(pushV.empty()&&popV.empty())
            return true;
        int l=pushV.size();
        vector<int> record;
        int k=0;
        for(int i=0;i<l;i++){
            record.push_back(pushV[i]);
            while(!record.empty()&&record.back()==popV[k]){
                record.pop_back();
                k++;
                }
            }
        if (record.empty())
            return 1;
        else
            return 0;
    }
```



JZ22：从上往下打印二叉树

题意：从上往下打印出二叉树的每个节点，同层节点从左至右打印。

方法：用上队列就很简单了，就是一个层序遍历，这里要注意的是队列的使用方法，先进先出，C++里面queue.pop()是void类型的，没有返回值的，要取队列首位元素需要用到queue.front()，然后别忘了再pop一下。

```c++
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        vector<int>re;
        //第一次提交没有加这个异常检测，没有通过，还是要边界检测呀
        if (root == NULL) {
            return re;
        }
        queue<TreeNode*>q;
        q.push(root);
        while (!q.empty())
        {
            root = q.front();
            q.pop();
            re.push_back(root->val);
            if (root->left != NULL)
                q.push(root->left);
            if (root->right != NULL)
                q.push(root->right);
        }
        return re;
    }
};
```



JZ26:二叉搜索树与双向链表

题意：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

方法：首先，二叉搜索树的性质是：根左小右大，本身有序，如果是中序遍历的话，就是顺序的，问题是双向链表返回的应该是最小或者最大的那个表头，所以考虑怎么返回左子树的最左节点，没有则是根节点，至于双向链表的顺序，只要将左子树的最右节点找到连上根节点，右子树的最左节点连上根节点就行。

两种方法：

一种，找左最右和右最左改变指针方向，返回左最左

```c++
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree==NULL)  return NULL;//递归边界
        if(pRootOfTree->left==NULL && pRootOfTree->right==NULL)  return pRootOfTree;//递归边界
        
        TreeNode* left = Convert(pRootOfTree->left);//递归左边
        TreeNode* p = left;
        while(p!=NULL && p->right!=NULL)//找左子树最右节点
            p = p->right;//当p->right为NULL的时候跳出循环
        if(left)//若左子树不空
        {
            p->right = pRootOfTree;
            pRootOfTree->left = p;
        }
        TreeNode* right = Convert(pRootOfTree->right);//递归右边
        if(right)//若右子树不空
        {
            pRootOfTree->right = right;
            right->left = pRootOfTree;
        }
        return left ? left : pRootOfTree;
    }
};
```



第二种，简单点，就是中序遍历

这里说明一下，个人认为像中序遍历那样，左中右或者右中左遍历修改指针都可以，但是这个牛客网上的题目通过好像只有返回最小的那个指针才能通过，也就是最左边的，所以如果采用左中右的方式的话，需要多申请一个指针存下最左边的那个节点，，，

我想了很久为什么直接输出右边的指针就是不行，是不是我理解错了？不过我试验了一下，故意输出右边的，就是不通过的，说明题目就是这样要求的，我没有理解错，不过会做就行了，理解算法就行啦，刷题嘛，不纠结。

```c++
class Solution {
public:
    //这是 左-中-右 的顺寻
    TreeNode* leftHead = NULL;
    TreeNode* rightHead  = NULL;
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        
        if(pRootOfTree==NULL)  return pRootOfTree;//递归边界
        Convert(pRootOfTree->left);
        if(rightHead==NULL){
            leftHead=rightHead=pRootOfTree;
        }else{
            rightHead->right=pRootOfTree;
            pRootOfTree->left=rightHead;
            rightHead=pRootOfTree;
        }
        Convert(pRootOfTree->right);
        return leftHead;
	}
}；
```

```c++
class Solution {
public:
    //这是 右-中-左 的顺序
    TreeNode* leftHead = NULL;
    //TreeNode* rightHead  = NULL;
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
       if(pRootOfTree==NULL)  return pRootOfTree;//递归边界
        Convert(pRootOfTree->right);
        if(rightHead==NULL){
            leftHead=pRootOfTree;
        }else{
            leftHead->left=pRootOfTree;
            pRootOfTree->right=leftHead;
            leftHead=pRootOfTree;
        }
        Convert(pRootOfTree->left);
        return leftHead;
    }
};
```



JZ28： 数组中出现次数超过一半的数字

题意：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

方法：最简单的，暴力求解，用字典一个一个统计个数，然后遍历一下，超过半长度的个数输出。一次成功。

c++的字典用map实现。

```c++
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        int l=numbers.size();
        map<int,int>dic;
        for(int i=0;i<l;i++){
            dic[numbers[i]]++;
        }
        map<int,int>::iterator it=dic.begin();
        for(it;it!=dic.end();it++){
            if(it->second>(l/2))
                return it->first;
        }
        return 0;
    
    }
};
```

方法二：数组排个序，查过半长的数字在中间一定有，也就是直接返回中间元素就行。

代码略，快排一下，返回就行。



题目提示用位操作和分治，再思考一下。。。





JZ40: 数组中只出现一次的数字

题意：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

这次是看的网上的解析才懂得（捂脸，太巧妙了）

方法：可以用哈希或者异或的方法，哈希就不多说了，一次遍历map构建一下，计数，二次遍历查数，对应赋值。这里给出一个在下认为最为巧妙的方法，**异或**。

异或的性质：

1. 交换律;
2. 结合律;
3. **a^a=0, a^0=a**, a^(-1)=~a。

所以：对于任意的a，有a^b^c^d^a^k = b^c^d^k^(a^a) = b^c^d^k^0 = b^c^d^k，也就是说，如果有多个数异或，其中有重复的数，则无论这些重复的数是否相邻，都可以根据异或的性质将其这些重复的数消去，具体来说，如果重复出现了偶数次，则异或后会全部消去，如果重复出现了奇数次，则异或后会保留一个。

下面来看两道题目：

1. 1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空间，能否设计一个算法实现？

    当然，这道题，可以用最直观的方法来做，将所有的数加起来，减去1+2+3+...+1000的和，得到的即是重复的那个数，该方法很容易理解，而且效率很高，也不需要辅助空间，唯一的不足时，如果范围不是1000，而是更大的数字，可能会发生溢出。我们考虑用异或操作来解决该问题。现在问题是要求重复的那个数字，我们姑且假设该数字式n吧，如果我们能想办法把1-1000中除n以外的数字全部异或两次，而数字n只异或一次，就可以把1-1000中出n以外的所有数字消去，这样就只剩下n了。我们首先把所有的数字异或，记为T，可以得到如下：

   ​				T = 1^2^3^4...^n...^n...^1000 = 1^2^3...^1000（结果中不含n）

   而后我们再让T与1-1000之间的所有数字（仅包含一个n）异或，便可得到该重复数字n。如下所示：

   ​				T^(a^2^3^4...^n...^1000) = T^(T^n) = 0^n = n

    这道题到此为止。

2. 一个数组中只有一个数字出现了一次，其他的全部出现了两次，求出这个数字。

   明白了上面题目的推导过程，这个就很容易了，将数组中所有的元素全部异或，最后出现两次的元素会全部被消去，而最后会得到该只出现一次的数字。该题目同样可以该为如下情景，思路是一样的：数组中只有一个数字出现了奇数次，其他的都出现了偶数次。

再来看JZ40，

采用同样的方法可以去除掉出现2次的数，但是最后的结果是只出现1次的两个数的异或结果，所以需要把这两个数给分开，怎么分呢？其他的数字其实不用考虑，因为一样的数字哪哪都是有一样的，只需要把那两个只出现1次的不一样的数字分开就行，这里还可以用到前面异或的结果，异或的本质是啥？不就是不一样为1吗，那么只要找到该结果里面一个为1的位（**不用怀疑前面的异或结果找不到1，如果找不到，说明那两个数是一样的，因为相同的数字才会异或结果为0**），不就说明这连个数字在该位上是一个1，一个0吗，然后就按这个标准分成两个数组，分别全部异或一下，不就求出这两个数字了吗。太精妙了。

```c++
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
		if(data.size() < 2) return ;
        int myxor = 0;
        int flag = 1;
        for(int i = 0 ; i < data.size(); ++ i )
            myxor ^= data[i];
        while((myxor & flag) == 0) flag <<= 1;
        //这一步就是找那个1，找到一个就行，随便哪一位，这里是从地位往高位找的。
        *num1 = myxor;
        *num2 = myxor;
        for(int i = 0; i < data.size(); ++ i ){
            //根据找到的那一位1，把数组分成了两个分别全部累计异或
            if((flag & data[i]) == 0) *num2 ^= data[i];
            else *num1 ^= data[i];
        }
    }
};
```



JZ55: 链表中环的入口结点

题意：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

方法：我最先想到的就是给遍历过的链表做标记，这样再见到的话就知道有环了，没有环到了尾巴就返回。

这里是用的map来标记遍历过的链表，有个问题，怎么判断是同一个链表呢？最严格的是直接判断链表的指针节点ListNode*，当然我这里是判断节点的元素int值，能够通过说明测试用例的链表元素是互异的，不过这里把 map<int,int> 改成 map<ListNode *,int> 也是可以的。

```c++
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        map<int,int>c;
        while (pHead!=NULL)
        {
            c[pHead->val]++;
            if(c[pHead->val]>=2){
                return pHead;
                break;
            }
            pHead=pHead->next;
        }
        return NULL;
    }
```

