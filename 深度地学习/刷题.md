## 刷题

### **nowcoder**

JZ4：重建二叉树

题解：就是根据前序和中序遍历的结果，重建二叉树。

方法：首先要吧遍历二叉树的过程给回忆一下

前序：根——>左——>右，

中序：左——>根——>右

后序：左——>右——>根

显然，前序的话，根节点一定是第一个，中序的话一定是在中间，然后中序的话根的左边是左子树，右边是右子树，所以显然用**递归**的话很简单就想到了，按照前序找到根节点，把中序遍历分成左右子树，然后有分别是一样的情况，因为中序遍历的话，子树也是中序遍历的顺序。

```c++
/*
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
*/
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) {
        return rebuilt(0, 0, pre.size() - 1, pre, vin);
    }
    TreeNode* rebuilt(int prestart, int vinstart, int size, vector<int> pre, vector<int> vin) {
        if (prestart >= pre.size() || vinstart > size) {
            return nullptr;
        }
        TreeNode* root = new TreeNode(pre[prestart]);
        int ii = 0;
        for (int i = vinstart; i <= size; i++) {
            if (pre[prestart] == vin[i]) {
                ii = i;
                break;
            }
        }
        root->left = rebuilt(prestart + 1, vinstart, ii - 1, pre, vin);
        root->right= rebuilt(prestart + 1 + ii - vinstart, ii + 1, size, pre, vin);
        return root;
    }
};
```





JZ21：栈的压入、弹出序列

题解：就是两个序列A，B，判断B是否为A的出栈序列。

方法：模拟A的入栈和出栈，然后以B的元素顺序最为出栈的指导。用一个向量vector当作栈，每次压栈，判断栈顶元素是否跟B的对应序列元素相同，一样就出栈，继续判断，不一样就继续按照A顺序压栈，最后把A的元素压弯，判断栈中元素是否能够都出来，都出来就说明B是一个正确的出栈顺序。

```c++
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        if(pushV.empty()&&popV.empty())
            return true;
        int l=pushV.size();
        vector<int> record;
        int k=0;
        for(int i=0;i<l;i++){
            record.push_back(pushV[i]);
            while(!record.empty()&&record.back()==popV[k]){
                record.pop_back();
                k++;
                }
            }
        if (record.empty())
            return 1;
        else
            return 0;
    }
```

任201803231505918
5940473



